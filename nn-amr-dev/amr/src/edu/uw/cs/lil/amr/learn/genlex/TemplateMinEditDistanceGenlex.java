/*******************************************************************************
 * UW SPF - The University of Washington Semantic Parsing Framework
 * <p>
 * Copyright (C) 2013 Yoav Artzi
 * <p>
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or any later version.
 * <p>
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * <p>
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 ******************************************************************************/
package edu.uw.cs.lil.amr.learn.genlex;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import edu.cornell.cs.nlp.spf.base.token.TokenSeq;
import edu.cornell.cs.nlp.spf.ccg.categories.ICategoryServices;
import edu.cornell.cs.nlp.spf.ccg.lexicon.ILexicon;
import edu.cornell.cs.nlp.spf.ccg.lexicon.ILexiconImmutable;
import edu.cornell.cs.nlp.spf.ccg.lexicon.LexicalEntry;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoredLexicalEntry;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoredLexicon;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoringServices;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.Lexeme;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.LexicalTemplate;
import edu.cornell.cs.nlp.spf.data.ILabeledDataItem;
import edu.cornell.cs.nlp.spf.data.sentence.Sentence;
import edu.cornell.cs.nlp.spf.data.situated.sentence.SituatedSentence;
import edu.cornell.cs.nlp.spf.explat.IResourceRepository;
import edu.cornell.cs.nlp.spf.explat.ParameterizedExperiment.Parameters;
import edu.cornell.cs.nlp.spf.explat.resources.IResourceObjectCreator;
import edu.cornell.cs.nlp.spf.explat.resources.usage.ResourceUsage;
import edu.cornell.cs.nlp.spf.genlex.ccg.AbstractLexiconGenerator;
import edu.cornell.cs.nlp.spf.genlex.ccg.ILexiconGenerator;
import edu.cornell.cs.nlp.spf.genlex.ccg.template.GenerationRepository;
import edu.cornell.cs.nlp.spf.genlex.ccg.template.GenerationRepositoryWithConstants;
import edu.cornell.cs.nlp.spf.mr.lambda.LogicalConstant;
import edu.cornell.cs.nlp.spf.mr.lambda.LogicalExpression;
import edu.cornell.cs.nlp.spf.mr.lambda.visitor.GetConstantsSet;
import edu.cornell.cs.nlp.spf.parser.ccg.model.IModelImmutable;
import edu.cornell.cs.nlp.spf.parser.ccg.model.IModelListener;
import edu.cornell.cs.nlp.utils.log.ILogger;
import edu.cornell.cs.nlp.utils.log.LoggerFactory;
import edu.cornell.cs.nlp.utils.string.StringUtils;
import edu.uw.cs.lil.amr.data.AMRMeta;
import edu.uw.cs.lil.amr.lambda.AMRServices;

/**
 * Generate single-token lexical entries by pairing templates with lexemes
 * generated by pairing words with the constants that have a minimum edit
 * distance with them. The edit distance can be bounded by a parameter and must
 * be smaller than the length of the token or constant base name.
 *
 * @author Yoav Artzi
 */
@Deprecated
public class TemplateMinEditDistanceGenlex<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>>
		extends
		AbstractLexiconGenerator<DI, LogicalExpression, IModelImmutable<Sentence, LogicalExpression>>
		implements IModelListener<LogicalExpression> {
	public static final ILogger			LOG					= LoggerFactory
			.create(TemplateMinEditDistanceGenlex.class);
	private static final long			serialVersionUID	= 1050225060829863094L;
	private final int					minDistance;
	private final GenerationRepository	repository;

	protected TemplateMinEditDistanceGenlex(GenerationRepository repository,
			String origin, int minDistance, boolean mark) {
		super(origin, mark);
		this.repository = repository;
		this.minDistance = minDistance;
		LOG.info("Init %s: #templates=%d, minDistance=%d",
				getClass().getSimpleName(), repository.getTemplates().size(),
				minDistance);
	}

	@Override
	public ILexicon<LogicalExpression> generate(DI dataItem,
			IModelImmutable<Sentence, LogicalExpression> model,
			ICategoryServices<LogicalExpression> categoryServices) {
		// Get set of all constants from the logical form. Filter constants that
		// are irrelevant.
		final Set<LogicalConstant> allConstants = GetConstantsSet
				.of(dataItem.getLabel()).stream()
				.filter(FactoringServices::isFactorable)
				.collect(Collectors.toSet());

		// For each token, find the closest constants (minimize edit distance).
		final TokenSeq tokens = dataItem.getSample().getTokens();
		final int numTokens = tokens.size();
		final List<Set<LogicalConstant>> minEditConstants = new ArrayList<>(
				numTokens);
		final int[] minEditDistances = new int[numTokens];
		for (int i = 0; i < numTokens; ++i) {
			final String token = tokens.get(i);
			final HashSet<LogicalConstant> constants = new HashSet<>();
			minEditConstants.add(constants);
			for (final LogicalConstant constant : allConstants) {
				final String constantLemma = AMRServices
						.lemmatizeConstant(constant);
				final int distance = StringUtils.editDistance(token,
						constantLemma);
				if (distance < token.length()
						&& distance < constantLemma.length()) {
					if (constants.isEmpty() || distance < minEditDistances[i]) {
						constants.clear();
						constants.add(constant);
						minEditDistances[i] = distance;
					} else if (distance == minEditDistances[i]) {
						constants.add(constant);
					}
				}
			}
		}

		final List<Lexeme> lexemes = new LinkedList<>();
		final GenerationRepositoryWithConstants repoWithConstants = repository
				.setConstants(allConstants);
		for (int i = 0; i < numTokens; ++i) {
			final TokenSeq token = tokens.sub(i, i + 1);
			final Set<LogicalConstant> constants = minEditConstants.get(i);
			LOG.debug("Edit distance: %s -> [%d] -> %s", token,
					minEditDistances[i], constants);
			if (minEditDistances[i] <= minDistance) {
				for (final LexicalTemplate template : repoWithConstants
						.getTemplates()) {
					final List<List<String>> attributes = repoWithConstants
							.getAttributeLists(template);
					lexemes.addAll(repoWithConstants.getConstantSeqs(template)
							.stream().filter(seq -> {
								// Only take lexemes that contain at least
								// one constant from the lemma set.
								for (final LogicalConstant c : seq) {
									if (constants.contains(c)) {
										return true;
									}
								}
								return false;
							}).map(seq -> attributes.stream()
									.map(attributeSeq -> {
										final Lexeme lexeme = new Lexeme(token,
												seq, attributeSeq,
												entryProperties);
										LOG.debug("Generated lexeme: %s",
												lexeme);
										return lexeme;
									}).collect(Collectors.toList()))
							.flatMap(Collection::stream)
							.collect(Collectors.toList()));

				}
			}
		}

		return new FactoredLexicon(lexemes, repoWithConstants.getTemplates());
	}

	@Override
	public void init(IModelImmutable<Sentence, LogicalExpression> model) {
		repository.init(model);
	}

	@Override
	public boolean isGenerated(LexicalEntry<LogicalExpression> entry) {
		return origin.equals(entry.getOrigin());
	}

	@Override
	public void lexicalEntriesAdded(
			Collection<LexicalEntry<LogicalExpression>> entries) {
		for (final LexicalEntry<LogicalExpression> entry : entries) {
			lexicalEntryAdded(entry);
		}
	}

	@Override
	public void lexicalEntriesAdded(ILexicon<LogicalExpression> entries) {
		lexicalEntriesAdded(entries.toCollection());
	}

	@Override
	public void lexicalEntryAdded(LexicalEntry<LogicalExpression> entry) {
		repository.addTemplate(FactoringServices.factor(entry).getTemplate());
	}

	public static class Builder<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>> {
		private final Set<String>				attributes	= new HashSet<>();

		private final boolean					mark;

		private int								minDistance	= Integer.MAX_VALUE;

		private String							origin		= ILexiconGenerator.GENLEX_LEXICAL_ORIGIN;

		protected final Set<LexicalTemplate>	templates	= new HashSet<>();

		public Builder(boolean mark) {
			this.mark = mark;
		}

		public Builder<SAMPLE, DI> addAttribute(String attribute) {
			attributes.add(attribute);
			return this;
		}

		public Builder<SAMPLE, DI> addAttributes(
				Iterable<String> attributesIterable) {
			for (final String attribute : attributesIterable) {
				addAttribute(attribute);
			}
			return this;
		}

		public Builder<SAMPLE, DI> addFromLexicon(
				ILexiconImmutable<LogicalExpression> lexicon) {
			final Collection<LexicalEntry<LogicalExpression>> lexicalEntries = lexicon
					.toCollection();
			for (final LexicalEntry<LogicalExpression> entry : lexicalEntries) {
				final FactoredLexicalEntry factored = FactoringServices
						.factor(entry);
				addTemplate(factored.getTemplate());
				addAttributes(factored.getLexeme().getAttributes());
			}
			return this;
		}

		public Builder<SAMPLE, DI> addFromModel(
				IModelImmutable<?, LogicalExpression> model) {
			addFromLexicon(model.getLexicon());
			return this;
		}

		public Builder<SAMPLE, DI> addTemplate(LexicalTemplate template) {
			templates.add(template);
			return this;
		}

		public Builder<SAMPLE, DI> addTemplates(
				Iterable<LexicalTemplate> templateCollection) {
			for (final LexicalTemplate template : templateCollection) {
				addTemplate(template);
			}
			return this;
		}

		public TemplateMinEditDistanceGenlex<SAMPLE, DI> build() {
			return new TemplateMinEditDistanceGenlex<>(
					new GenerationRepository(templates, attributes), origin,
					minDistance, mark);
		}

		public Builder<SAMPLE, DI> setMinDistance(int minDistance) {
			this.minDistance = minDistance;
			return this;
		}

		public Builder<SAMPLE, DI> setOrigin(String origin) {
			this.origin = origin;
			return this;
		}

	}

	public static class Creator<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>>
			implements
			IResourceObjectCreator<TemplateMinEditDistanceGenlex<SAMPLE, DI>> {

		private final String type;

		public Creator() {
			this("genlex.template.editdist");
		}

		public Creator(String type) {
			this.type = type;
		}

		@SuppressWarnings("unchecked")
		@Override
		public TemplateMinEditDistanceGenlex<SAMPLE, DI> create(
				Parameters params, IResourceRepository repo) {
			final TemplateMinEditDistanceGenlex.Builder<SAMPLE, DI> builder = new TemplateMinEditDistanceGenlex.Builder<>(
					params.getAsBoolean("mark", false));

			if (params.contains("templatesModel")) {
				builder.addFromModel(
						(IModelImmutable<?, LogicalExpression>) repo
								.get(params.get("model")));
			} else if (params.contains("lexicon")) {
				builder.addFromLexicon((ILexicon<LogicalExpression>) repo
						.get(params.get("lexicon")));
			} else {
				throw new IllegalStateException(
						"no templates source specified");
			}

			if (params.contains("minDistance")) {
				builder.setMinDistance(params.getAsInteger("minDistance"));
			}

			if (params.contains("origin")) {
				builder.setOrigin(params.get("origin"));
			}

			return builder.build();
		}

		@Override
		public String type() {
			return type;
		}

		@Override
		public ResourceUsage usage() {
			return new ResourceUsage.Builder(type(),
					TemplateMinEditDistanceGenlex.class)
							.addParam("model", "Model",
									"Model object to get templates from")
							.addParam("lexicon", "ILexicon",
									"Lexicon to get templates from")
							.addParam("maxTokens", "int",
									"Max number of tokens to consider for new lexical entries")
							.addParam("origin", String.class,
									"Origin of generated entries (default: "
											+ ILexiconGenerator.GENLEX_LEXICAL_ORIGIN
											+ ")")
							.addParam("mark", Boolean.class,
									"Mark generated entries (default: false)")
							.setDescription(
									"Generate single-token lexical entries by pairing templates with lexemes generated by pairing words with the constants that have a minimum edit distance with them. The edit distance can be bounded by a parameter and must be smaller than the length of the token or constant base name.")
							.build();
		}

	}

}
