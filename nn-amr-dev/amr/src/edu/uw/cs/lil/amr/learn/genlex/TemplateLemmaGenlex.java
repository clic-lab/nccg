/*******************************************************************************
 * UW SPF - The University of Washington Semantic Parsing Framework
 * <p>
 * Copyright (C) 2013 Yoav Artzi
 * <p>
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or any later version.
 * <p>
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * <p>
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 ******************************************************************************/
package edu.uw.cs.lil.amr.learn.genlex;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import edu.cornell.cs.nlp.spf.base.token.TokenSeq;
import edu.cornell.cs.nlp.spf.ccg.categories.ICategoryServices;
import edu.cornell.cs.nlp.spf.ccg.lexicon.ILexicon;
import edu.cornell.cs.nlp.spf.ccg.lexicon.ILexiconImmutable;
import edu.cornell.cs.nlp.spf.ccg.lexicon.LexicalEntry;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoredLexicalEntry;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoredLexicon;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.FactoringServices;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.Lexeme;
import edu.cornell.cs.nlp.spf.ccg.lexicon.factored.lambda.LexicalTemplate;
import edu.cornell.cs.nlp.spf.data.ILabeledDataItem;
import edu.cornell.cs.nlp.spf.data.sentence.Sentence;
import edu.cornell.cs.nlp.spf.data.situated.sentence.SituatedSentence;
import edu.cornell.cs.nlp.spf.explat.IResourceRepository;
import edu.cornell.cs.nlp.spf.explat.ParameterizedExperiment.Parameters;
import edu.cornell.cs.nlp.spf.explat.resources.IResourceObjectCreator;
import edu.cornell.cs.nlp.spf.explat.resources.usage.ResourceUsage;
import edu.cornell.cs.nlp.spf.genlex.ccg.AbstractLexiconGenerator;
import edu.cornell.cs.nlp.spf.genlex.ccg.ILexiconGenerator;
import edu.cornell.cs.nlp.spf.genlex.ccg.template.GenerationRepository;
import edu.cornell.cs.nlp.spf.genlex.ccg.template.GenerationRepositoryWithConstants;
import edu.cornell.cs.nlp.spf.mr.lambda.LogicalConstant;
import edu.cornell.cs.nlp.spf.mr.lambda.LogicalExpression;
import edu.cornell.cs.nlp.spf.mr.lambda.visitor.GetConstantsSet;
import edu.cornell.cs.nlp.spf.parser.ccg.model.IModelImmutable;
import edu.cornell.cs.nlp.spf.parser.ccg.model.IModelListener;
import edu.cornell.cs.nlp.utils.log.ILogger;
import edu.cornell.cs.nlp.utils.log.LoggerFactory;
import edu.uw.cs.lil.amr.data.AMRMeta;
import edu.uw.cs.lil.amr.features.LemmaLexemeFeatures;
import edu.uw.cs.lil.amr.lambda.AMRServices;

/**
 * Lemmatized template-based GENLEX that uses the labeled logical form to get
 * the set of constants to instantiate the templates. Each word in the sentence
 * is lemmatized and if the lemma matches one of the constants in the labeled
 * logical form, a {@link Lexeme} is created. Lexemes with multiple constants
 * are generated by taking the lemmatiztion-generated constant and pairing with
 * other constants, as necessary according to available templates.
 *
 * @author Yoav Artzi
 * @see LemmaLexemeFeatures
 */
@Deprecated
public class TemplateLemmaGenlex<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>>
		extends
		AbstractLexiconGenerator<DI, LogicalExpression, IModelImmutable<Sentence, LogicalExpression>>
		implements IModelListener<LogicalExpression> {
	public static final ILogger			LOG					= LoggerFactory
			.create(TemplateLemmaGenlex.class);
	private static final long			serialVersionUID	= -5169902554015748269L;
	private final GenerationRepository	repository;

	protected TemplateLemmaGenlex(GenerationRepository repository,
			String origin, boolean mark) {
		super(origin, mark);
		this.repository = repository;
		LOG.info("Init %s: #templates=%d", getClass().getSimpleName(),
				repository.getTemplates().size());
	}

	@Override
	public ILexicon<LogicalExpression> generate(DI dataItem,
			IModelImmutable<Sentence, LogicalExpression> model,
			ICategoryServices<LogicalExpression> categoryServices) {
		// Get set of all constants from the logical form. Filter constants that
		// are irrelevant. And create a map of the expected lemmatized form to
		// the set of relevant constant. Store in least for efficiency.
		final Set<LogicalConstant> allConstants = GetConstantsSet
				.of(dataItem.getLabel()).stream()
				.filter(FactoringServices::isFactorable)
				.collect(Collectors.toSet());
		final Map<String, Set<LogicalConstant>> constants = new HashMap<>();
		allConstants.stream().forEach((c) -> {

			final String lemma = AMRServices.lemmatizeConstant(c);
			if (!constants.containsKey(lemma)) {
				constants.put(lemma, new HashSet<>());
			}
			constants.get(lemma).add(c);
		});

		final List<Lexeme> lexemes = new LinkedList<>();
		final TokenSeq tokens = dataItem.getSample().getTokens();
		final int numTokens = tokens.size();
		final GenerationRepositoryWithConstants repoWithConstants = repository
				.setConstants(allConstants);
		for (int i = 0; i < numTokens; ++i) {
			final TokenSeq token = tokens.sub(i, i + 1);
			for (final String lemma : dataItem.getSample().getState()
					.getLemmas(i)) {
				if (constants.containsKey(lemma)) {
					final Set<LogicalConstant> lemmaConstants = constants
							.get(lemma);
					for (final LexicalTemplate template : repoWithConstants
							.getTemplates()) {
						final List<List<String>> attributes = repoWithConstants
								.getAttributeLists(template);
						lexemes.addAll(
								repoWithConstants.getConstantSeqs(template)
										.stream().filter(seq -> {
											// Only take lexemes that contain at
											// least
											// one constant from the lemma set.
											for (final LogicalConstant c : seq) {
												if (lemmaConstants
														.contains(c)) {
													return true;
												}
											}
											return false;
										}).map(seq -> attributes.stream()
												.map(attributeSeq -> {
													final Lexeme lexeme = new Lexeme(
															token, seq,
															attributeSeq,
															entryProperties);
													LOG.debug(
															"Generated lexeme: %s",
															lexeme);
													return lexeme;
												}).collect(Collectors.toList()))
										.flatMap(Collection::stream)
										.collect(Collectors.toList()));

					}

				}
			}
		}

		return new FactoredLexicon(lexemes, repoWithConstants.getTemplates());
	}

	@Override
	public void init(IModelImmutable<Sentence, LogicalExpression> model) {
		repository.init(model);
	}

	@Override
	public boolean isGenerated(LexicalEntry<LogicalExpression> entry) {
		return origin.equals(entry.getOrigin());
	}

	@Override
	public void lexicalEntriesAdded(
			Collection<LexicalEntry<LogicalExpression>> entries) {
		for (final LexicalEntry<LogicalExpression> entry : entries) {
			lexicalEntryAdded(entry);
		}
	}

	@Override
	public void lexicalEntriesAdded(ILexicon<LogicalExpression> entries) {
		lexicalEntriesAdded(entries.toCollection());
	}

	@Override
	public void lexicalEntryAdded(LexicalEntry<LogicalExpression> entry) {
		repository.addTemplate(FactoringServices.factor(entry).getTemplate());
	}

	public static class Builder<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>> {
		private final Set<String>				attributes	= new HashSet<>();

		private final boolean					mark;

		private String							origin		= ILexiconGenerator.GENLEX_LEXICAL_ORIGIN;

		protected final Set<LexicalTemplate>	templates	= new HashSet<>();

		public Builder(boolean mark) {
			this.mark = mark;
		}

		public Builder<SAMPLE, DI> addAttribute(String attribute) {
			attributes.add(attribute);
			return this;
		}

		public Builder<SAMPLE, DI> addAttributes(
				Iterable<String> attributesIterable) {
			for (final String attribute : attributesIterable) {
				addAttribute(attribute);
			}
			return this;
		}

		public Builder<SAMPLE, DI> addFromLexicon(
				ILexiconImmutable<LogicalExpression> lexicon) {
			final Collection<LexicalEntry<LogicalExpression>> lexicalEntries = lexicon
					.toCollection();
			for (final LexicalEntry<LogicalExpression> entry : lexicalEntries) {
				final FactoredLexicalEntry factored = FactoringServices
						.factor(entry);
				addTemplate(factored.getTemplate());
				addAttributes(factored.getLexeme().getAttributes());
			}
			return this;
		}

		public Builder<SAMPLE, DI> addFromModel(
				IModelImmutable<?, LogicalExpression> model) {
			addFromLexicon(model.getLexicon());
			return this;
		}

		public Builder<SAMPLE, DI> addTemplate(LexicalTemplate template) {
			templates.add(template);
			return this;
		}

		public Builder<SAMPLE, DI> addTemplates(
				Iterable<LexicalTemplate> templateCollection) {
			for (final LexicalTemplate template : templateCollection) {
				addTemplate(template);
			}
			return this;
		}

		public TemplateLemmaGenlex<SAMPLE, DI> build() {
			return new TemplateLemmaGenlex<>(
					new GenerationRepository(templates, attributes), origin,
					mark);
		}

		public Builder<SAMPLE, DI> setOrigina(String originaLabel) {
			this.origin = originaLabel;
			return this;
		}

	}

	public static class Creator<SAMPLE extends SituatedSentence<AMRMeta>, DI extends ILabeledDataItem<SAMPLE, LogicalExpression>>
			implements IResourceObjectCreator<TemplateLemmaGenlex<SAMPLE, DI>> {

		private final String type;

		public Creator() {
			this("genlex.template.lemma");
		}

		public Creator(String type) {
			this.type = type;
		}

		@SuppressWarnings("unchecked")
		@Override
		public TemplateLemmaGenlex<SAMPLE, DI> create(Parameters params,
				IResourceRepository repo) {
			final TemplateLemmaGenlex.Builder<SAMPLE, DI> builder = new TemplateLemmaGenlex.Builder<>(
					params.getAsBoolean("mark", false));

			if (params.contains("templatesModel")) {
				builder.addFromModel(
						(IModelImmutable<?, LogicalExpression>) repo
								.get(params.get("model")));
			} else if (params.contains("lexicon")) {
				builder.addFromLexicon((ILexicon<LogicalExpression>) repo
						.get(params.get("lexicon")));
			} else {
				throw new IllegalStateException(
						"no templates source specified");
			}

			if (params.contains("origin")) {
				builder.setOrigina(params.get("origin"));
			}

			return builder.build();
		}

		@Override
		public String type() {
			return type;
		}

		@Override
		public ResourceUsage usage() {
			return new ResourceUsage.Builder(type(), TemplateLemmaGenlex.class)
					.addParam("model", "Model",
							"Model object to get templates from")
					.addParam("lexicon", "ILexicon",
							"Lexicon to get templates from")
					.addParam("origin", String.class,
							"Origin of generated entries (default: "
									+ ILexiconGenerator.GENLEX_LEXICAL_ORIGIN
									+ ")")
					.addParam("mark", Boolean.class,
							"Mark generated entries (default: false)")
					.build();
		}

	}

}
